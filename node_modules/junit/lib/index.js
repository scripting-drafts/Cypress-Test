"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _yaku = require("yaku");

var _yaku2 = _interopRequireDefault(_yaku);

var _yakuLibUtils = require("yaku/lib/utils");

var _yakuLibUtils2 = _interopRequireDefault(_yakuLibUtils);

var _utils = require("./utils");

var _utils2 = _interopRequireDefault(_utils);

var _reporter = require("./reporter");

var _reporter2 = _interopRequireDefault(_reporter);

var _brush = require("./brush");

var _brush2 = _interopRequireDefault(_brush);

/**
 * A simple promise based module for unit tests.
 * @param  {Object} opts Defaults:
 * ```js
 * {
 *     // Stop test when error occurred.
 *     isBail: true,
 *
 *     isFailOnUnhandled: true,
 *
 *     // If any test failed, when process finished, set exit code to failed number.
 *     isExitWithFailed: true,
 *
 *     // Fail a test after timeout.
 *     timeout: 5000,
 *
 *     reporter: {
 *         // You can even use jsdiff here to generate more fancy error info.
 *         formatAssertErr: (actual, expected, stack) => {},
 *
 *         logPass: (msg, span) => {},
 *         logFail: (msg, err, span) => {},
 *         logFinal: (total, tested, passed, failed) => {}
 *     }
 * }
 * ```
 * @return {Function} `() => Function : { msg: String }`
 * @example
 * ```js
 * import junit from "junit";
 * let it = junit();
 *
 * // Async tests.
 * it.run([
 *     it("test 1", () =>
 *         // We use `it.eq` to assert on both simple type and complex object.
 *         it.eq("ok", "ok")
 *     ),
 *     it("test 2", async () => {
 *         // No more callback hell while testing async functions.
 *         await new junit.Promise(r => setTimeout(r, 1000));
 *
 *         return it.eq({ a: 1, b: 2 }, { a: 1, b: 2 });
 *     }),
 *
 *     // Run sync tests within the main async flow.
 *     async () => {
 *         await it("test 3", () =>
 *             it.eq("ok", "ok")
 *         )();
 *
 *         await it("test 4", () =>
 *             it.eq("ok", "ok")
 *         )();
 *     }
 * ]);
 * ```
 * @example
 * Filter the tests, only the odd ones will be tested.
 * ```js
 * import junit from "junit";
 * let it = junit();
 *
 * (async () => {
 *     // Get the result of the test.
 *     let { total, passed, failed } = await it.run(1,
 *         [
 *             it("test 1", () => it.eq(1, 1)),
 *             it("test 2", () => it.eq(1, 2)),
 *             it("test 3", () => it.eq(2, 2))
 *         ]
 *         .filter((fn, index) => index % 2)
 *         .map(fn => {
 *             // prefix all the messages with current file path
 *             fn.msg = `${__filename} - ${fn.msg}`
 *             return fn
 *         })
 *     );
 *
 *     console.log(total, passed, failed);
 * })();
 * ```
 * @example
 * You can even change the code style like this.
 * ```js
 * import junit from "junit";
 * import assert from "assert";
 * let it = junit();
 *
 * (async () => {
 *     await it("test 2", async () => {
 *         await new junit.Promise(r => setTimeout(r, 1000));
 *         return it.eq(1, 2);
 *     })();
 *
 *     await it("test 2", async () => {
 *         await new junit.Promise(r => setTimeout(r, 1000));
 *
 *         // Use return or await here are the same.
 *         await it.eq(1, 2);
 *     })();
 *
 *     await it("test 2", async () => {
 *         // You can use any assert tool you like.
 *         // You only have to follow one rule, the async assertion should be
 *         // returned within a promise.
 *         assert.equal(1, 2);
 *     })();
 *
 *     return it.run();
 * })();
 * ```
 */
var junit = function junit() {
    var opts = arguments.length <= 0 || arguments[0] === undefined ? {} : arguments[0];

    var root = typeof window === "object" ? window : global;

    opts = _utils2["default"].extend({
        isBail: true,
        isFailOnUnhandled: true,
        isExitWithFailed: true,
        timeout: 5000,
        reporter: {}
    }, opts);

    var _utils$extend = _utils2["default"].extend((0, _reporter2["default"])(_brush2["default"].underline(_brush2["default"].grey("junit >"))), opts.reporter);

    var formatAssertErr = _utils$extend.formatAssertErr;
    var logPass = _utils$extend.logPass;
    var logFail = _utils$extend.logFail;
    var logFinal = _utils$extend.logFinal;

    var passed = 0;
    var failed = 0;
    var total = 0;
    var tested = 0;
    var isEnd = false;

    if (opts.isFailOnUnhandled) {
        (function () {
            var onUnhandledRejection = _yaku2["default"].onUnhandledRejection;
            _yaku2["default"].onUnhandledRejection = function (reason, p) {
                failed++;
                onUnhandledRejection(reason, p);
            };
        })();
    }

    function it(msg, fn) {
        total++;
        function testFn() {
            tested++;
            var timeouter = null;
            var startTime = Date.now();
            return new _yaku2["default"](function (resolve, reject) {
                resolve(fn());
                timeouter = setTimeout(reject, opts.timeout, new Error("test_timeout"));
            }).then(function () {
                clearTimeout(timeouter);
                if (isEnd) return;
                passed++;
                logPass(testFn.msg, Date.now() - startTime);
            }, function (err) {
                clearTimeout(timeouter);
                if (isEnd) return;
                failed++;
                logFail(testFn.msg, err, Date.now() - startTime);
                if (opts.isBail) return _yaku2["default"].reject(err);
            });
        }

        testFn.msg = msg;

        return testFn;
    }

    function onFinal() {
        isEnd = true;
        logFinal(total, tested, passed, failed);

        return { total: total, tested: tested, passed: passed, failed: failed };
    }

    if (opts.isExitWithFailed && root.process)
        /* istanbul ignore next */
        root.process.on("exit", function () {
            return process.exit(failed);
        });

    return _utils2["default"].extend(it, {

        /**
         * Almost the same with the `yutils.async`, additionally, it will
         * monitor the result of the whole tests.
         * @param  {Int} limit The max task to run at a time. It's optional.
         * Default is `Infinity`. Set it to 1 to run tests synchronously.
         * @param  {Array | Function} list
         * If the list is an array, it should be a list of functions or promises,
         * and each function will return a promise.
         * If the list is a function, it should be a iterator that returns
         * a promise, when it returns `yutils.end`, the iteration ends. Of course
         * it can never end.
         * @return {Promise} It will resolve `{ total, passed, failed }`
         */
        run: function run(limit, list) {
            if (arguments.length === 0) limit = [];

            return _yakuLibUtils2["default"].async(limit, list, false).then(onFinal, onFinal);
        },

        /**
         * A smart strict deep equality assertion helper function.
         * @param {Any} actual
         * @param {Any} expected
         * @param {Number = 7} maxDepth Optional. The max depth of the recursion check.
         * @return {Promise}
         */
        eq: _utils2["default"].eq(formatAssertErr)

    });
};

/**
 * An example reporter for junit.
 * @param {String} prompt The prompt prefix.
 * @return {Function} `() => Object`.
 * @example
 * ```js
 * let it = junit({ reporter: junit.reporter('my-prompt > ') });
 * ```
 */
junit.reporter = _reporter2["default"];

/**
 * The promise class that junit uses: [Yaku](https://github.com/ysmood/yaku)
 * @type {Object}
 */
junit.Promise = _yaku2["default"];

/**
 * The promise helpers: [Yaku Utils](https://github.com/ysmood/yaku#utils)
 * @type {Object}
 */
junit.yutils = _yakuLibUtils2["default"];

exports["default"] = junit;
module.exports = exports["default"];