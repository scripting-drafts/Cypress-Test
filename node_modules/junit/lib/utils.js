"use strict";

Object.defineProperty(exports, "__esModule", {
    value: true
});

function _interopRequireDefault(obj) { return obj && obj.__esModule ? obj : { "default": obj }; }

var _yaku = require("yaku");

var _yaku2 = _interopRequireDefault(_yaku);

function stringify(val) {
    if (typeof val === "undefined") {
        return "undefined";
    } else {
        return JSON.stringify(val, 0, 4);
    }
}

var report = function report(formatAssertErr, actual, expected) {
    var _ref = new Error("Assertion");

    var stack = _ref.stack;

    /* istanbul ignore next */
    if (typeof __filename !== "undefined") stack = stack.replace(new RegExp(".+" + __filename + ".+\\n", "g"), "");

    return _yaku2["default"].reject(formatAssertErr(stringify(actual), stringify(expected), stack));
};

var isArray = function isArray(json) {
    return json && typeof json === "object" && typeof json.length === "number";
};

var getNames = function getNames(json) {
    var names = [];
    if (json && typeof json === "object") {
        for (var name in json) {
            names.push(name);
        }
    }
    return names;
};

var isPureObj = function isPureObj(json) {
    return json && typeof json === "object" && !isArray(json);
};

var getLen = function getLen(json) {
    return isArray(json) ? json.length : getNames(json).length;
};

var nextPath = function nextPath(path, next) {
    return path === "" ? next : path + "." + next;
};

var joinRes = function joinRes(res, json1, json2, path) {
    return res ? { pass: true } : { pass: false, path: path, json1: json1, json2: json2 };
};

// used as an unique object for exception
var $maxDepthErr = {};

var _eq = function _eq(json1, json2, depthCountdown) {
    var path = arguments.length <= 3 || arguments[3] === undefined ? "" : arguments[3];

    if (depthCountdown === 0) {
        return $maxDepthErr;
    }
    var isBothArr = isArray(json1) && isArray(json2);
    var isBothObj = isPureObj(json1) && isPureObj(json2);

    var json = getLen(json1) > getLen(json2) ? json1 : json2;
    if (isBothArr) {
        for (var i = 0; i < json.length; i++) {
            var eqRes = _eq(json1[i], json2[i], depthCountdown - 1, nextPath(path, i));
            if ($maxDepthErr === eqRes) return $maxDepthErr;
            if (!eqRes.pass) return eqRes;
        }
    } else if (isBothObj) {
        for (var _name in json) {
            var eqRes = _eq(json1[_name], json2[_name], depthCountdown - 1, nextPath(path, _name));
            if ($maxDepthErr === eqRes) return $maxDepthErr;
            if (!eqRes.pass) return eqRes;
        }
    } else if (json1 !== json2) {
        return joinRes(false, json1, json2, path);
    }

    return joinRes(true);
};

exports["default"] = {
    extend: function extend(obj, src) {
        for (var key in src) {
            obj[key] = src[key];
        }
        return obj;
    },

    eq: function eq(formatAssertErr) {
        return function (actual, expected) {
            var depthCountdown = arguments.length <= 2 || arguments[2] === undefined ? 7 : arguments[2];

            var eqRes = _eq(actual, expected, depthCountdown);
            if (eqRes === $maxDepthErr) {
                var errText = "Maximum recursion depth exceeded: " + depthCountdown;
                return report(formatAssertErr, errText, errText);
            }
            if (eqRes.pass) return _yaku2["default"].resolve();

            return report(formatAssertErr, actual, expected);
        };
    }
};
module.exports = exports["default"];